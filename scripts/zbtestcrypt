#! /usr/bin/env python

#  zbtestcrypt - test encryption by decrypting and re-encrypting
# 
#  Adam Laurie <adam@aperturelabs.com>
#  http://www.aperturelabs.com
# 

import sys
import argparse

from scapy.all import *
from killerbee import *
from killerbee.scapy_extensions import *

# encrypt/decrypt packet with appropriate key
def crypt(packet, data= None, encrypt= False):
    global link_key
    global nwk_key

    if packet[ZigbeeSecurityHeader].key_type == 0:
        if link_key == None:
            return False, 'FAILED: No LINK_KEY provided'
        key= link_key
    elif packet[ZigbeeSecurityHeader].key_type == 1:
        if nwk_key == None:
            return False, 'FAILED: No NWK_KEY provided'
        key= nwk_key
    else:
        return False, 'Unknown KEY type'

    if encrypt:
        return True, kbencrypt(packet, data, key, verbose= args.verbose)
    else:
        return True, kbdecrypt(packet, key, verbose= args.verbose)

if __name__ == '__main__':
    # Command-line arguments
    parser = argparse.ArgumentParser(description="zbtestcrypt: \
        Decrypt, re-encrypt and optionally transmit packets for testing and tool development.")
    parser.add_argument('-c', '--channel', action='store', type=int, default=11,
        help='tx/rx on given channel (default 11)')
    parser.add_argument('-D', action='store_true', dest='showdev',
        help='list KillerBee devices')
    parser.add_argument('-i', '--interface', action='store', type=str, default=None,
        help='provide the USB ID or Serial Device Path to use that device')
    parser.add_argument('-k', '--network_key', action='store', type=str, default=None,
        help='provide the NWK_KEY in HEX')
    parser.add_argument('-l', '--link_key', action='store', type=str, default=None,
        help='provide the LINK_KEY in HEX (APS layer not yet implemented!)')
    parser.add_argument('-r', '--pcapfile', action='store', default=None,
        help='pcap file to test')
    parser.add_argument('-R', '--dsnafile', action='store', default=None,
        help='Daintree SNA file to test')
    parser.add_argument('-s', '--sleep', action='store', type=float, default=1.0,
        help='if tx, wait given seconds between packet injections (default 1.0)')
    parser.add_argument('-t', '--transmit_both', action='store_true', dest='transmit_both',
        help='Transmit original and re-encrypted packets for independant capture/analysis')
    parser.add_argument('-T', '--transmit_crypted', action='store_true', dest='transmit_crypted',
        help='Transmit only re-encrypted packets for independant capture/analysis')
    parser.add_argument('-v', '--verbose', action='store', type=int, default=0,
        help='tx/rx on given channel (default 11)')
    args = parser.parse_args()

    if args.showdev:
        show_dev()
        exit(False)

    if args.pcapfile == None and args.dsnafile == None:
        print >>sys.stderr, "ERROR: Must specify a capture file using -r (libpcap) or -R (Daintree SNA)"
        exit(True)

    if args.pcapfile != None and args.dsnafile != None:
        print >>sys.stderr, "ERROR: Must specify only one of -r (libpcap) or -R (Daintree SNA)"
        exit(True)

    if args.network_key and len(args.network_key) != 32:
        print >>sys.stderr, "ERROR: Must specify 16 byte NWK_KEY in HEX"
        exit(True)
    if args.network_key:
        try:
            nwk_key= args.network_key.decode('hex')
        except:
            print >>sys.stderr, "ERROR: Invalid NWK_KEY"
            exit(True)

    if args.link_key and len(args.link_key) != 32:
        print >>sys.stderr, "ERROR: Must specify 16 byte LINK_KEY in HEX"
        exit(True)
    if args.link_key:
        try:
            link_key= args.link_key.decode('hex')
            print >>sys.stderr, "WARNING: APS Layer crypto net yet implemented!"
        except:
            print >>sys.stderr, "ERROR: Invalid LINK_KEY"
            exit(True)

    if args.pcapfile is not None:
        data= kbrdpcap(args.pcapfile)

    if args.dsnafile is not None:
        data= kbrddain(args.dsnafile)

    print
    print '%d packets read' % len(data)

    count= 0
    testcount= 0
    failed= 0
    passed= 0

    for packet in data:
        count += 1
        print
        print 'Packet:', count
        print '  ', packet.summary()
        if args.verbose:
            print '  ', repr(packet)

        # ignore frames with no encrypted payload
        if not packet.haslayer(ZigbeeNWK) or not packet.haslayer(ZigbeeSecurityHeader):
            print '    no payload - skipping!'
            continue

        if packet.haslayer(ZigbeeSecurityHeader):
            print '   decrypting...'
            stat, decrypted = crypt(packet)
            if stat:
                print '     ', decrypted.summary()
                if args.verbose:
                    print '     ', repr(decrypted)
            else:
                print '     ', decrypted
            # If APS layer build new packet with ZigbeeNWK so we can decrypt it
            if decrypted.haslayer(ZigbeeAppDataPayload):
                aps_encrypted = decrypted[ZigbeeAppDataPayload]
                tmppkt = copy.copy(packet)
                tmppkt[ZigbeeNWK].remove_payload()
                tmppkt /= aps_encrypted
                print '      decrypting APS...'
                stat, app_decrypt= crypt(tmppkt)
                if stat:
                    print '          ', app_decrypt.summary()
                    if args.verbose:
                        print '          ', repr(app_decrypt)
                else:
                    print '          ', app_decrypt
            print '      encrypting...'
            stat, newpkt= crypt(packet, data= decrypted, encrypt= True)
            if stat:
                if args.verbose:
                    print '  ', repr(newpkt)
            else:
                print '     ', newpkt
            if newpkt == packet:
                print '        Packet match: OK'
                passed += 1
            else:
                print '        Packet match: FAILED!'
                failed += 1

        if args.transmit_both:
            print '      transmitting ORIGINAL'
            try:
                kbsendp(packet, channel=args.channel, inter=args.sleep)
                print '        OK'
            except:
                print '        FAILED!'
        if args.transmit_crypted or args.transmit_both:
            print '      transmitting RE-ENCRYPTED'
            try:
                kbsendp(newpkt, channel=args.channel, inter=args.sleep)
                print '        OK'
            except:
                print '        FAILED!'
        testcount += 1

    print
    print '%d of %d packets tested' % (testcount, len(data))
    print 'crypto passed:', passed
    print 'crypto failed:', failed
    exit(False)
